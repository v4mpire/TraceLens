"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.CVEUpdateScheduler = void 0;
class CVEUpdateScheduler {
    constructor(fetcher, config = {}) {
        this.isRunning = false;
        this.fetcher = fetcher;
        this.config = {
            updateInterval: 6 * 60 * 60 * 1000, // 6 hours default
            maxRetries: 3,
            retryDelay: 5 * 60 * 1000, // 5 minutes
            ...config
        };
    }
    start() {
        if (this.isRunning) {
            console.warn('CVE update scheduler is already running');
            return;
        }
        this.isRunning = true;
        console.log('Starting CVE update scheduler');
        // Run initial update
        this.performUpdate();
        // Schedule periodic updates
        this.intervalId = setInterval(() => {
            this.performUpdate();
        }, this.config.updateInterval);
    }
    stop() {
        if (!this.isRunning) {
            return;
        }
        this.isRunning = false;
        if (this.intervalId) {
            clearInterval(this.intervalId);
            this.intervalId = undefined;
        }
        console.log('CVE update scheduler stopped');
    }
    async performUpdate() {
        if (!this.isRunning) {
            return;
        }
        console.log('Starting CVE database update');
        let retries = 0;
        while (retries < this.config.maxRetries) {
            try {
                const modifiedSince = this.lastUpdate || new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
                const cves = await this.fetcher.fetchRecentCVEs({
                    modifiedSince,
                    maxResults: 1000
                });
                if (cves.length > 0) {
                    console.log(`Fetched ${cves.length} CVE updates`);
                    if (this.config.onUpdate) {
                        await this.config.onUpdate(cves);
                    }
                }
                else {
                    console.log('No new CVE updates found');
                }
                this.lastUpdate = new Date();
                return; // Success, exit retry loop
            }
            catch (error) {
                retries++;
                const errorMsg = error instanceof Error ? error.message : 'Unknown error';
                console.error(`CVE update failed (attempt ${retries}/${this.config.maxRetries}):`, errorMsg);
                if (this.config.onError) {
                    this.config.onError(error instanceof Error ? error : new Error(errorMsg));
                }
                if (retries < this.config.maxRetries) {
                    console.log(`Retrying in ${this.config.retryDelay / 1000} seconds...`);
                    await this.delay(this.config.retryDelay);
                }
            }
        }
        console.error('CVE update failed after all retries');
    }
    getStatus() {
        return {
            isRunning: this.isRunning,
            lastUpdate: this.lastUpdate,
            nextUpdate: this.lastUpdate
                ? new Date(this.lastUpdate.getTime() + this.config.updateInterval)
                : undefined
        };
    }
    delay(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
exports.CVEUpdateScheduler = CVEUpdateScheduler;
