"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.CVEFetcher = void 0;
// CVE database integration with NVD and OSV
const node_fetch_1 = __importDefault(require("node-fetch"));
class CVEFetcher {
    constructor(apiKey) {
        this.baseUrls = {
            nvd: 'https://services.nvd.nist.gov/rest/json/cves/2.0',
            osv: 'https://api.osv.dev/v1'
        };
        this.nvdApiKey = apiKey;
    }
    async fetchRecentCVEs(options = {}) {
        const cves = [];
        // Fetch from NVD
        try {
            const nvdCVEs = await this.fetchFromNVD(options);
            cves.push(...nvdCVEs);
        }
        catch (error) {
            console.warn('Failed to fetch from NVD:', error);
        }
        // Fetch from OSV for additional coverage
        try {
            const osvCVEs = await this.fetchFromOSV(options);
            cves.push(...osvCVEs);
        }
        catch (error) {
            console.warn('Failed to fetch from OSV:', error);
        }
        // Deduplicate by CVE ID
        const uniqueCVEs = new Map();
        for (const cve of cves) {
            if (!uniqueCVEs.has(cve.id) || uniqueCVEs.get(cve.id).modified < cve.modified) {
                uniqueCVEs.set(cve.id, cve);
            }
        }
        return Array.from(uniqueCVEs.values());
    }
    async fetchFromNVD(options) {
        const params = new URLSearchParams();
        if (options.modifiedSince) {
            params.append('lastModStartDate', options.modifiedSince.toISOString());
        }
        if (options.maxResults) {
            params.append('resultsPerPage', Math.min(options.maxResults, 2000).toString());
        }
        const headers = {
            'Accept': 'application/json'
        };
        if (this.nvdApiKey) {
            headers['apiKey'] = this.nvdApiKey;
        }
        const response = await (0, node_fetch_1.default)(`${this.baseUrls.nvd}?${params}`, { headers });
        if (!response.ok) {
            throw new Error(`NVD API error: ${response.status} ${response.statusText}`);
        }
        const data = await response.json();
        return data.vulnerabilities?.map((vuln) => this.parseNVDVulnerability(vuln)) || [];
    }
    async fetchFromOSV(options) {
        // OSV query for recent vulnerabilities
        const query = {
            page_token: '',
            query: {
                modified_after: options.modifiedSince?.toISOString() || new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()
            }
        };
        const response = await (0, node_fetch_1.default)(`${this.baseUrls.osv}/query`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(query)
        });
        if (!response.ok) {
            throw new Error(`OSV API error: ${response.status} ${response.statusText}`);
        }
        const data = await response.json();
        return data.vulns?.map((vuln) => this.parseOSVVulnerability(vuln)) || [];
    }
    parseNVDVulnerability(vuln) {
        const cve = vuln.cve;
        const metrics = cve.metrics?.cvssMetricV31?.[0] || cve.metrics?.cvssMetricV30?.[0];
        return {
            id: cve.id,
            published: cve.published,
            modified: cve.lastModified,
            severity: this.mapSeverity(metrics?.cvssData?.baseSeverity || 'UNKNOWN'),
            score: metrics?.cvssData?.baseScore || 0,
            vectorString: metrics?.cvssData?.vectorString,
            description: cve.descriptions?.find((d) => d.lang === 'en')?.value || '',
            affectedPackages: this.extractAffectedPackages(cve.configurations),
            references: cve.references?.map((ref) => ref.url) || []
        };
    }
    parseOSVVulnerability(vuln) {
        return {
            id: vuln.id,
            published: vuln.published,
            modified: vuln.modified,
            severity: this.mapSeverity(vuln.severity?.[0]?.type || 'UNKNOWN'),
            score: vuln.severity?.[0]?.score || 0,
            description: vuln.summary || vuln.details || '',
            affectedPackages: vuln.affected?.map((pkg) => ({
                ecosystem: pkg.package?.ecosystem || 'unknown',
                name: pkg.package?.name || '',
                versionRange: pkg.ranges?.[0]?.events?.map((e) => Object.entries(e).map(([k, v]) => `${k}:${v}`).join(',')).join(';') || ''
            })) || [],
            references: vuln.references?.map((ref) => ref.url) || []
        };
    }
    mapSeverity(severity) {
        switch (severity.toUpperCase()) {
            case 'LOW': return 'LOW';
            case 'MEDIUM': return 'MEDIUM';
            case 'HIGH': return 'HIGH';
            case 'CRITICAL': return 'CRITICAL';
            default: return 'MEDIUM';
        }
    }
    extractAffectedPackages(configurations) {
        // Simplified extraction - in practice would need more sophisticated parsing
        const packages = [];
        if (!configurations?.nodes)
            return packages;
        for (const node of configurations.nodes) {
            if (node.cpeMatch) {
                for (const match of node.cpeMatch) {
                    if (match.vulnerable && match.criteria) {
                        const cpe = match.criteria.split(':');
                        if (cpe.length >= 5) {
                            packages.push({
                                ecosystem: cpe[2] || 'unknown',
                                name: cpe[4] || '',
                                versionRange: match.versionStartIncluding || match.versionEndExcluding || '*'
                            });
                        }
                    }
                }
            }
        }
        return packages;
    }
}
exports.CVEFetcher = CVEFetcher;
