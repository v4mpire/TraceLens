// Vulnerability matching against runtime dependencies
import { CVEData } from './cve-fetcher';

export interface VulnerabilityMatch {
  cveId: string;
  packageName: string;
  packageVersion: string;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  score: number;
  description: string;
  matchConfidence: number; // 0-1 scale
  affectedVersions: string[];
  fixedVersions: string[];
}

export interface RuntimeDependency {
  name: string;
  version: string;
  ecosystem: string;
  path?: string;
  metadata?: Record<string, any>;
}

export class VulnerabilityMatcher {
  public matchVulnerabilities(
    dependencies: RuntimeDependency[], 
    cves: CVEData[]
  ): VulnerabilityMatch[] {
    const matches: VulnerabilityMatch[] = [];

    for (const dependency of dependencies) {
      for (const cve of cves) {
        const match = this.checkMatch(dependency, cve);
        if (match) {
          matches.push(match);
        }
      }
    }

    // Sort by severity and confidence
    return matches.sort((a, b) => {
      const severityOrder = { 'CRITICAL': 4, 'HIGH': 3, 'MEDIUM': 2, 'LOW': 1 };
      const severityDiff = severityOrder[b.severity] - severityOrder[a.severity];
      if (severityDiff !== 0) return severityDiff;
      return b.matchConfidence - a.matchConfidence;
    });
  }

  private checkMatch(dependency: RuntimeDependency, cve: CVEData): VulnerabilityMatch | null {
    for (const affectedPkg of cve.affectedPackages) {
      // Check ecosystem match
      if (!this.ecosystemMatches(dependency.ecosystem, affectedPkg.ecosystem)) {
        continue;
      }

      // Check package name match
      const nameMatch = this.packageNameMatches(dependency.name, affectedPkg.name);
      if (nameMatch.confidence < 0.8) {
        continue;
      }

      // Check version match
      const versionMatch = this.versionMatches(dependency.version, affectedPkg.versionRange);
      if (!versionMatch.isVulnerable) {
        continue;
      }

      // Calculate overall confidence
      const confidence = (nameMatch.confidence + versionMatch.confidence) / 2;

      return {
        cveId: cve.id,
        packageName: dependency.name,
        packageVersion: dependency.version,
        severity: cve.severity,
        score: cve.score,
        description: cve.description,
        matchConfidence: confidence,
        affectedVersions: versionMatch.affectedVersions,
        fixedVersions: versionMatch.fixedVersions
      };
    }

    return null;
  }

  private ecosystemMatches(depEcosystem: string, cveEcosystem: string): boolean {
    const normalizedDep = depEcosystem.toLowerCase();
    const normalizedCve = cveEcosystem.toLowerCase();

    // Direct match
    if (normalizedDep === normalizedCve) return true;

    // Common ecosystem mappings
    const mappings: Record<string, string[]> = {
      'npm': ['node.js', 'nodejs', 'javascript'],
      'pypi': ['python', 'pip'],
      'maven': ['java'],
      'nuget': ['.net', 'dotnet', 'c#'],
      'rubygems': ['ruby', 'gem'],
      'go': ['golang'],
      'cargo': ['rust']
    };

    for (const [ecosystem, aliases] of Object.entries(mappings)) {
      if ((normalizedDep === ecosystem && aliases.includes(normalizedCve)) ||
          (normalizedCve === ecosystem && aliases.includes(normalizedDep))) {
        return true;
      }
    }

    return false;
  }

  private packageNameMatches(depName: string, cveName: string): { confidence: number } {
    const normalizedDep = depName.toLowerCase().replace(/[-_]/g, '');
    const normalizedCve = cveName.toLowerCase().replace(/[-_]/g, '');

    // Exact match
    if (normalizedDep === normalizedCve) {
      return { confidence: 1.0 };
    }

    // Substring match
    if (normalizedDep.includes(normalizedCve) || normalizedCve.includes(normalizedDep)) {
      return { confidence: 0.9 };
    }

    // Levenshtein distance for fuzzy matching
    const distance = this.levenshteinDistance(normalizedDep, normalizedCve);
    const maxLength = Math.max(normalizedDep.length, normalizedCve.length);
    const similarity = 1 - (distance / maxLength);

    return { confidence: similarity > 0.8 ? similarity : 0 };
  }

  private versionMatches(depVersion: string, versionRange: string): {
    isVulnerable: boolean;
    confidence: number;
    affectedVersions: string[];
    fixedVersions: string[];
  } {
    // Simplified version matching - in practice would use semver library
    const cleanDepVersion = this.normalizeVersion(depVersion);
    
    // Parse version range (simplified)
    const ranges = versionRange.split(';').map(r => r.trim()).filter(r => r);
    
    let isVulnerable = false;
    const affectedVersions: string[] = [];
    const fixedVersions: string[] = [];

    for (const range of ranges) {
      if (range.includes('introduced:')) {
        const introduced = range.split('introduced:')[1];
        if (introduced && this.compareVersions(cleanDepVersion, introduced) >= 0) {
          isVulnerable = true;
          affectedVersions.push(`>=${introduced}`);
        }
      }
      
      if (range.includes('fixed:')) {
        const fixed = range.split('fixed:')[1];
        if (fixed) {
          if (this.compareVersions(cleanDepVersion, fixed) < 0) {
            isVulnerable = true;
          } else {
            isVulnerable = false;
          }
          fixedVersions.push(fixed);
        }
      }

      // Simple range patterns
      if (range.startsWith('>=') || range.startsWith('<=') || range.startsWith('<') || range.startsWith('>')) {
        const operator = range.match(/^[<>=]+/)?.[0] || '';
        const version = range.replace(operator, '');
        
        if (version) {
          const comparison = this.compareVersions(cleanDepVersion, version);
          
          switch (operator) {
            case '>=':
              if (comparison >= 0) isVulnerable = true;
              break;
            case '<=':
              if (comparison <= 0) isVulnerable = true;
              break;
            case '<':
              if (comparison < 0) isVulnerable = true;
              break;
            case '>':
              if (comparison > 0) isVulnerable = true;
              break;
          }
        }
      }
    }

    return {
      isVulnerable,
      confidence: 0.9, // High confidence for version matching
      affectedVersions,
      fixedVersions
    };
  }

  private normalizeVersion(version: string): string {
    // Remove common prefixes and normalize
    const normalized = version.replace(/^[v^~]/, '').split('-')[0];
    return normalized || '0.0.0';
  }

  private compareVersions(v1: string, v2: string): number {
    const parts1 = v1.split('.').map(n => parseInt(n) || 0);
    const parts2 = v2.split('.').map(n => parseInt(n) || 0);
    
    const maxLength = Math.max(parts1.length, parts2.length);
    
    for (let i = 0; i < maxLength; i++) {
      const part1 = parts1[i] || 0;
      const part2 = parts2[i] || 0;
      
      if (part1 > part2) return 1;
      if (part1 < part2) return -1;
    }
    
    return 0;
  }

  private levenshteinDistance(str1: string, str2: string): number {
    const matrix: (number | null)[][] = Array(str2.length + 1).fill(null).map(() => Array(str1.length + 1).fill(null));

    for (let i = 0; i <= str1.length; i++) {
      matrix[0]![i] = i;
    }
    for (let j = 0; j <= str2.length; j++) {
      matrix[j]![0] = j;
    }

    for (let j = 1; j <= str2.length; j++) {
      for (let i = 1; i <= str1.length; i++) {
        const indicator = str1[i - 1] === str2[j - 1] ? 0 : 1;
        matrix[j]![i] = Math.min(
          matrix[j]![i - 1]! + 1,     // deletion
          matrix[j - 1]![i]! + 1,     // insertion
          matrix[j - 1]![i - 1]! + indicator // substitution
        );
      }
    }

    return matrix[str2.length]![str1.length]!;
  }
}
