// Periodic CVE database updates
import { CVEFetcher, CVEData } from '../cve-fetcher';

export interface UpdateSchedulerConfig {
  updateInterval: number; // milliseconds
  maxRetries: number;
  retryDelay: number;
  onUpdate?: (cves: CVEData[]) => Promise<void>;
  onError?: (error: Error) => void;
}

export class CVEUpdateScheduler {
  private fetcher: CVEFetcher;
  private config: UpdateSchedulerConfig;
  private intervalId?: NodeJS.Timeout;
  private lastUpdate?: Date;
  private isRunning = false;

  constructor(fetcher: CVEFetcher, config: Partial<UpdateSchedulerConfig> = {}) {
    this.fetcher = fetcher;
    this.config = {
      updateInterval: 6 * 60 * 60 * 1000, // 6 hours default
      maxRetries: 3,
      retryDelay: 5 * 60 * 1000, // 5 minutes
      ...config
    };
  }

  public start(): void {
    if (this.isRunning) {
      console.warn('CVE update scheduler is already running');
      return;
    }

    this.isRunning = true;
    console.log('Starting CVE update scheduler');

    // Run initial update
    this.performUpdate();

    // Schedule periodic updates
    this.intervalId = setInterval(() => {
      this.performUpdate();
    }, this.config.updateInterval);
  }

  public stop(): void {
    if (!this.isRunning) {
      return;
    }

    this.isRunning = false;
    
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = undefined;
    }

    console.log('CVE update scheduler stopped');
  }

  public async performUpdate(): Promise<void> {
    if (!this.isRunning) {
      return;
    }

    console.log('Starting CVE database update');
    
    let retries = 0;
    while (retries < this.config.maxRetries) {
      try {
        const modifiedSince = this.lastUpdate || new Date(Date.now() - 7 * 24 * 60 * 60 * 1000);
        
        const cves = await this.fetcher.fetchRecentCVEs({
          modifiedSince,
          maxResults: 1000
        });

        if (cves.length > 0) {
          console.log(`Fetched ${cves.length} CVE updates`);
          
          if (this.config.onUpdate) {
            await this.config.onUpdate(cves);
          }
        } else {
          console.log('No new CVE updates found');
        }

        this.lastUpdate = new Date();
        return; // Success, exit retry loop

      } catch (error) {
        retries++;
        const errorMsg = error instanceof Error ? error.message : 'Unknown error';
        console.error(`CVE update failed (attempt ${retries}/${this.config.maxRetries}):`, errorMsg);

        if (this.config.onError) {
          this.config.onError(error instanceof Error ? error : new Error(errorMsg));
        }

        if (retries < this.config.maxRetries) {
          console.log(`Retrying in ${this.config.retryDelay / 1000} seconds...`);
          await this.delay(this.config.retryDelay);
        }
      }
    }

    console.error('CVE update failed after all retries');
  }

  public getStatus(): {
    isRunning: boolean;
    lastUpdate?: Date;
    nextUpdate?: Date;
  } {
    return {
      isRunning: this.isRunning,
      lastUpdate: this.lastUpdate,
      nextUpdate: this.lastUpdate 
        ? new Date(this.lastUpdate.getTime() + this.config.updateInterval)
        : undefined
    };
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
