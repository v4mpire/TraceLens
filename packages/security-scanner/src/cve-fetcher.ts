// CVE database integration with NVD and OSV
import fetch from 'node-fetch';

export interface CVEData {
  id: string;
  published: string;
  modified: string;
  severity: 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL';
  score: number;
  vectorString?: string;
  description: string;
  affectedPackages: Array<{
    ecosystem: string;
    name: string;
    versionRange: string;
  }>;
  references: string[];
}

export interface FetchOptions {
  apiKey?: string;
  maxResults?: number;
  modifiedSince?: Date;
}

export class CVEFetcher {
  private nvdApiKey?: string;
  private baseUrls = {
    nvd: 'https://services.nvd.nist.gov/rest/json/cves/2.0',
    osv: 'https://api.osv.dev/v1'
  };

  constructor(apiKey?: string) {
    this.nvdApiKey = apiKey;
  }

  public async fetchRecentCVEs(options: FetchOptions = {}): Promise<CVEData[]> {
    const cves: CVEData[] = [];
    
    // Fetch from NVD
    try {
      const nvdCVEs = await this.fetchFromNVD(options);
      cves.push(...nvdCVEs);
    } catch (error) {
      console.warn('Failed to fetch from NVD:', error);
    }

    // Fetch from OSV for additional coverage
    try {
      const osvCVEs = await this.fetchFromOSV(options);
      cves.push(...osvCVEs);
    } catch (error) {
      console.warn('Failed to fetch from OSV:', error);
    }

    // Deduplicate by CVE ID
    const uniqueCVEs = new Map<string, CVEData>();
    for (const cve of cves) {
      if (!uniqueCVEs.has(cve.id) || uniqueCVEs.get(cve.id)!.modified < cve.modified) {
        uniqueCVEs.set(cve.id, cve);
      }
    }

    return Array.from(uniqueCVEs.values());
  }

  private async fetchFromNVD(options: FetchOptions): Promise<CVEData[]> {
    const params = new URLSearchParams();
    
    if (options.modifiedSince) {
      params.append('lastModStartDate', options.modifiedSince.toISOString());
    }
    
    if (options.maxResults) {
      params.append('resultsPerPage', Math.min(options.maxResults, 2000).toString());
    }

    const headers: Record<string, string> = {
      'Accept': 'application/json'
    };

    if (this.nvdApiKey) {
      headers['apiKey'] = this.nvdApiKey;
    }

    const response = await fetch(`${this.baseUrls.nvd}?${params}`, { headers });
    
    if (!response.ok) {
      throw new Error(`NVD API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json() as any;
    
    return data.vulnerabilities?.map((vuln: any) => this.parseNVDVulnerability(vuln)) || [];
  }

  private async fetchFromOSV(options: FetchOptions): Promise<CVEData[]> {
    // OSV query for recent vulnerabilities
    const query = {
      page_token: '',
      query: {
        modified_after: options.modifiedSince?.toISOString() || new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString()
      }
    };

    const response = await fetch(`${this.baseUrls.osv}/query`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(query)
    });

    if (!response.ok) {
      throw new Error(`OSV API error: ${response.status} ${response.statusText}`);
    }

    const data = await response.json() as any;
    
    return data.vulns?.map((vuln: any) => this.parseOSVVulnerability(vuln)) || [];
  }

  private parseNVDVulnerability(vuln: any): CVEData {
    const cve = vuln.cve;
    const metrics = cve.metrics?.cvssMetricV31?.[0] || cve.metrics?.cvssMetricV30?.[0];
    
    return {
      id: cve.id,
      published: cve.published,
      modified: cve.lastModified,
      severity: this.mapSeverity(metrics?.cvssData?.baseSeverity || 'UNKNOWN'),
      score: metrics?.cvssData?.baseScore || 0,
      vectorString: metrics?.cvssData?.vectorString,
      description: cve.descriptions?.find((d: any) => d.lang === 'en')?.value || '',
      affectedPackages: this.extractAffectedPackages(cve.configurations),
      references: cve.references?.map((ref: any) => ref.url) || []
    };
  }

  private parseOSVVulnerability(vuln: any): CVEData {
    return {
      id: vuln.id,
      published: vuln.published,
      modified: vuln.modified,
      severity: this.mapSeverity(vuln.severity?.[0]?.type || 'UNKNOWN'),
      score: vuln.severity?.[0]?.score || 0,
      description: vuln.summary || vuln.details || '',
      affectedPackages: vuln.affected?.map((pkg: any) => ({
        ecosystem: pkg.package?.ecosystem || 'unknown',
        name: pkg.package?.name || '',
        versionRange: pkg.ranges?.[0]?.events?.map((e: any) => 
          Object.entries(e).map(([k, v]) => `${k}:${v}`).join(',')
        ).join(';') || ''
      })) || [],
      references: vuln.references?.map((ref: any) => ref.url) || []
    };
  }

  private mapSeverity(severity: string): 'LOW' | 'MEDIUM' | 'HIGH' | 'CRITICAL' {
    switch (severity.toUpperCase()) {
      case 'LOW': return 'LOW';
      case 'MEDIUM': return 'MEDIUM';
      case 'HIGH': return 'HIGH';
      case 'CRITICAL': return 'CRITICAL';
      default: return 'MEDIUM';
    }
  }

  private extractAffectedPackages(configurations: any): Array<{ecosystem: string; name: string; versionRange: string}> {
    // Simplified extraction - in practice would need more sophisticated parsing
    const packages: Array<{ecosystem: string; name: string; versionRange: string}> = [];
    
    if (!configurations?.nodes) return packages;

    for (const node of configurations.nodes) {
      if (node.cpeMatch) {
        for (const match of node.cpeMatch) {
          if (match.vulnerable && match.criteria) {
            const cpe = match.criteria.split(':');
            if (cpe.length >= 5) {
              packages.push({
                ecosystem: cpe[2] || 'unknown',
                name: cpe[4] || '',
                versionRange: match.versionStartIncluding || match.versionEndExcluding || '*'
              });
            }
          }
        }
      }
    }

    return packages;
  }
}
